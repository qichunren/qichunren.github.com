<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | 蕲春人的博客]]></title>
  <link href="http://qichunren.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://qichunren.github.io/"/>
  <updated>2013-05-22T00:32:13+08:00</updated>
  <id>http://qichunren.github.io/</id>
  <author>
    <name><![CDATA[qichunren]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用SSH代理来访访问远程mysql机器]]></title>
    <link href="http://qichunren.github.io/blog/2012-06-04-use-ssh-proxy-port-trick/"/>
    <updated>2012-06-04T17:31:00+08:00</updated>
    <id>http://qichunren.github.io/blog/use-ssh-proxy-port-trick</id>
    <content type="html"><![CDATA[<p>默认安装的mysql的Linux机器基于安全的原因，一般不支持mysql的远程连接访问。有几种方法可以修改配置来让mysql服务器支持远程连接。但是通过ssh的代理功能，可以不用修改服务器配置，来支持从远程连接mysql服务器。</p>

<p>在本地通过ssh连接远程的mysql所在的服务器</p>

<p><code>
ssh -L 1036:localhost:3306 root@xxx.xx.xx.xxx
</code></p>

<p>这样就将远程的mysql主机代理到本地了，端口是1036。 <a href="http://zh.wikipedia.org/zh/SSH">SSH</a>太强大了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过update-rc.d来管理Ubuntu系统的自动启动程序]]></title>
    <link href="http://qichunren.github.io/blog/2012-03-14-how-to-managing-services-with-update-rc-dot-d/"/>
    <updated>2012-03-14T11:30:00+08:00</updated>
    <id>http://qichunren.github.io/blog/how-to-managing-services-with-update-rc-dot-d</id>
    <content type="html"><![CDATA[<p>转载, 并记下我的使用心得。</p>

<p>Linux services can be started, stopped and reloaded with the use of scripts stocked in /etc/init.d/.
However, during start up or when changing runlevel, those scripts are searched in /etc/rcX.d/ where X is the runlevel number.
This tutorial will explain how one can activate, deactivate or modify a service start up.
When installing a new service under debian, the default is to enable it. So for instance, if you just installed apache2 package, after you installed it, apache service will be started and so will it be upon the next reboots.
If you do not use apache all the time, you might want to disable this service from starting up upon boot up and simply start it manually when you actually need it by running this command:
<code>
/etc/init.d/apache2 start
</code></p>

<p>You could either disable this service on boot up by removing any symbolic links in <strong><em>/etc/rcX.d/SYYapache2</em></strong> or by using <strong>update-rc.d</strong>.
The advantage of using update-rc.d is that it will take care of removing/adding any required links to /etc/init.d automatically.
Taking apache2 as an example, let's examine how /etc/rcX.d is looking like:</p>

<p>```</p>

<h1>ls -l /etc/rc?.d/*apache2</h1>

<p>lrwxrwxrwx 1 root root 17 2007-07-05 22:51 /etc/rc0.d/K91apache2 -> ../init.d/apache2
lrwxrwxrwx 1 root root 17 2007-07-05 22:51 /etc/rc1.d/K91apache2 -> ../init.d/apache2
lrwxrwxrwx 1 root root 17 2007-07-05 22:51 /etc/rc2.d/S91apache2 -> ../init.d/apache2
lrwxrwxrwx 1 root root 17 2007-07-05 22:51 /etc/rc3.d/S91apache2 -> ../init.d/apache2
lrwxrwxrwx 1 root root 17 2007-07-05 22:51 /etc/rc4.d/S91apache2 -> ../init.d/apache2
lrwxrwxrwx 1 root root 17 2007-07-05 22:51 /etc/rc5.d/S91apache2 -> ../init.d/apache2
lrwxrwxrwx 1 root root 17 2007-07-05 22:51 /etc/rc6.d/K91apache2 -> ../init.d/apache2
```</p>

<p>As you can see, for runlevels 0, 1 and 6 there is a K at the beginning of the link, for runlevels 2, 3, 4 and 5, there is a S. Those two letters stands for Kill and Start.
On Debian and Ubuntu, runlevels 2, 3, 4 and 5 are multi-users runlevels.
Runlevel 0 is Halt.
Runlevel 1 is single user mode
Runlevel 6 is reboot</p>

<h3>1. Removing A Service</h3>

<p>If you want to totally disable apache2 service by hand, you would need to delete every single link in /etc/rcX.d/. Using <strong>update-rc.d</strong> it is as simple as:
<code>
update-rc.d -f apache2 remove
</code>
The use of <strong><em>-f</em></strong> is to force the removal of the symlinks even if there is still /etc/init.d/apache2.</p>

<pre><code>    Note: This command will only disable the service until next time the service is upgraded. If you want to make sure the service won't be re-enabled upon upgrade, you should also type the following:
    # update-rc.d apache2 stop 80 0 1 2 3 4 5 6 .
</code></pre>

<h3>2. Adding A Service</h3>

<h4>2.1. Default Priorities</h4>

<p>Now, if you want to re-add this service to be started on boot up, you can simply use:</p>

<p>```</p>

<h1>update-rc.d apache2 defaults</h1>

<p>Adding system startup for /etc/init.d/apache2 ...
/etc/rc0.d/K20apache2 -> ../init.d/apache2
/etc/rc1.d/K20apache2 -> ../init.d/apache2
/etc/rc6.d/K20apache2 -> ../init.d/apache2
/etc/rc2.d/S20apache2 -> ../init.d/apache2
/etc/rc3.d/S20apache2 -> ../init.d/apache2
/etc/rc4.d/S20apache2 -> ../init.d/apache2
/etc/rc5.d/S20apache2 -> ../init.d/apache2
```</p>

<h4>2.2. Custom Priorities</h4>

<p>But as you can see, the default value is 20 which is pretty different than 91 ... a S20 link is started before a S91 and and K91 is kill before K20.
To force apache2 to be started with priorities 91 for both Start and Kill, we need to use the following command:
```</p>

<h1>update-rc.d apache2 defaults 91</h1>

<p>Adding system startup for /etc/init.d/apache2 ...
/etc/rc0.d/K91apache2 -> ../init.d/apache2
/etc/rc1.d/K91apache2 -> ../init.d/apache2
/etc/rc6.d/K91apache2 -> ../init.d/apache2
/etc/rc2.d/S91apache2 -> ../init.d/apache2
/etc/rc3.d/S91apache2 -> ../init.d/apache2
/etc/rc4.d/S91apache2 -> ../init.d/apache2
/etc/rc5.d/S91apache2 -> ../init.d/apache2
```</p>

<h3>2.3. Different Priorities For Start And Kill</h3>

<p> Alternatively, if you want to set different priorities for Start than for Kill, let say Start with 20 and Kill with 80, you will need to run:</p>

<p>```</p>

<h1>update-rc.d apache2 defaults 20 80</h1>

<p>Adding system startup for /etc/init.d/apache2 ...
/etc/rc0.d/K80apache2 -> ../init.d/apache2
/etc/rc1.d/K80apache2 -> ../init.d/apache2
/etc/rc6.d/K80apache2 -> ../init.d/apache2
/etc/rc2.d/S20apache2 -> ../init.d/apache2
/etc/rc3.d/S20apache2 -> ../init.d/apache2
/etc/rc4.d/S20apache2 -> ../init.d/apache2
/etc/rc5.d/S20apache2 -> ../init.d/apache2
```</p>

<h2>3. Specifying Custom Runlevels</h2>

<p>Finally, if you only want to Start and Kill on specific runlevels, like for instance starting apache with priority 20 on runlevels 2, 3, 4 and 5 and Kill with priority 80 on runlevels 0, 1 and 6:</p>

<p>```</p>

<h1>update-rc.d apache2 start 20 2 3 4 5 . stop 80 0 1 6 .</h1>

<p>Adding system startup for /etc/init.d/apache2 ...
/etc/rc0.d/K80apache2 -> ../init.d/apache2
/etc/rc1.d/K80apache2 -> ../init.d/apache2
/etc/rc6.d/K80apache2 -> ../init.d/apache2
/etc/rc2.d/S20apache2 -> ../init.d/apache2
/etc/rc3.d/S20apache2 -> ../init.d/apache2
/etc/rc4.d/S20apache2 -> ../init.d/apache2
/etc/rc5.d/S20apache2 -> ../init.d/apache2
```</p>

<p>Or, to start with priority 20 for runlevel 2, 3 and 4 and priority 30 for runlevel 5 and kill with priority 80 for runlevel 0, 1 and 6:</p>

<p>```</p>

<h1>update-rc.d apache2 start 20 2 3 4 . start 30 5 . stop 80 0 1 6 .</h1>

<p>Adding system startup for /etc/init.d/apache2 ...
/etc/rc0.d/K80apache2 -> ../init.d/apache2
/etc/rc1.d/K80apache2 -> ../init.d/apache2
/etc/rc6.d/K80apache2 -> ../init.d/apache2
/etc/rc2.d/S20apache2 -> ../init.d/apache2
/etc/rc3.d/S20apache2 -> ../init.d/apache2
/etc/rc4.d/S20apache2 -> ../init.d/apache2
/etc/rc5.d/S30apache2 -> ../init.d/apache2
```</p>

<h2>我的总结</h2>

<p>通过 update-rc.d 来管理Linux下开机自动运行，的确很方便，但是我在实际部署实践中，还是遇到了一些问题，导致开机后没有正常自动启动，但是手工通过service xxx start可以启动。我经过排查发现，原因是在Linux系统启动中，在执行/etc/init.d/中的脚本时，此时系统有可能没有加载好系统中的PATH变量，所以需要在init.d脚本中手工指定，对于使用Ruby脚本写的程序，需要GEM_HOME\GEM_PATH等环境变量，我这里是用RVM来管理Ruby的，这是我使用的：
<code>
PATH="/usr/local/rvm/gems/ruby-1.9.2-p290/bin:/usr/local/rvm/rubies/ruby-1.9.2-p290/bin:/usr/local/rvm/bin:/opt/node/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games"
RUBY_VERSION="ruby-1.9.2-p290"
GEM_HOME="/usr/local/rvm/gems/ruby-1.9.2-p290"
GEM_PATH="/usr/local/rvm/gems/ruby-1.9.2-p290:/usr/local/rvm/gems/ruby-1.9.2-p290@global"
export PATH=$PATH
export RUBY_VERSION=$RUBY_VERSION
export GEM_HOME=$GEM_HOME
export GEM_PATH=$GEM_PATH
</code></p>

<p> 另外还有一些其它的变量（如果你的启动程序需要），也需要手工指定，如在Ruby 1.9中，就有可能需要指定，比如说unicorn启动脚本：
<code>
export LANG='en_US.UTF-8'
</code></p>

<p>最后附上一个常用的init.d启动脚本的样本：
{% codeblock /etc/init.d/ntgps lang:bash %}</p>

<h1>!/bin/sh</h1>

<h3>BEGIN INIT INFO</h3>

<h1>Provides:          gps</h1>

<h1>Required-Start:    $syslog $remote_fs $network</h1>

<h1>Required-Stop:     $syslog $remote_fs $network</h1>

<h1>Should-Start:      fam</h1>

<h1>Should-Stop:       fam</h1>

<h1>Default-Start:     2 3 4 5</h1>

<h1>Default-Stop:      0 1 6</h1>

<h1>Short-Description: Start the gps.</h1>

<h3>END INIT INFO</h3>

<p>PATH=/usr/local/rvm/gems/ruby-1.9.2-p290/bin:/usr/local/rvm/gems/ruby-1.9.2-p290@global/bin:/usr/local/rvm/rubies/ruby-1.9.2-p290/bin:/usr/local/rvm/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
DAEMON=/www/georgia/current/lib/gps/gps.rb
NAME=ntgps
DESC="ntgps daemon"
PIDFILE=/var/run/$NAME.pid
SCRIPTNAME=/etc/init.d/$NAME</p>

<p>DAEMON_OPTS=""</p>

<p>set -e
. /lib/lsb/init-functions
export LANG='en_US.UTF-8'
export PATH=$PATH
export GEM_HOME=/usr/local/rvm/gems/ruby-1.9.2-p290
export GEM_PATH=/usr/local/rvm/gems/ruby-1.9.2-p290:/usr/local/rvm/gems/ruby-1.9.2-p290@global</p>

<p>case "$1" in</p>

<pre><code>start)
    log_daemon_msg "Starting $DESC" $NAME
    if ! start-stop-daemon --start -m --background --oknodo --quiet --pidfile $PIDFILE --exec /usr/local/rvm/rubies/ruby-1.9.2-p290/bin/ruby $DAEMON -- $DAEMON_OPTS
    then
        log_end_msg 1
    else
        log_end_msg 0
    fi
    ;;
stop)
    log_daemon_msg "Stopping $DESC" $NAME
    if kill  -9 `cat $PIDFILE`
    then
        rm -f $PIDFILE
        log_end_msg 0
    else
        log_end_msg 1
    fi
    ;;
restart)
    $0 stop
    $0 start
    ;;
status)
    status_of_proc -p "$PIDFILE" "$DAEMON" $NAME &amp;&amp; exit 0 || exit $?
    ;;
*)
    echo "Usage: $SCRIPTNAME {start|stop|restart|status}" &gt;&amp;2
    exit 1
    ;;
</code></pre>

<p>esac</p>

<p>exit 0</p>

<p>{% endcodeblock %}</p>

<h2>Resources:</h2>

<p><a href="http://www.debuntu.org/how-to-manage-services-with-update-rc.d">How-To: Managing services with update-rc.d</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shell学习小记录]]></title>
    <link href="http://qichunren.github.io/blog/2011-10-18-learning-shell-tip-note/"/>
    <updated>2011-10-18T20:44:00+08:00</updated>
    <id>http://qichunren.github.io/blog/learning-shell-tip-note</id>
    <content type="html"><![CDATA[<p>最近为了一些自动化的任务，要写一些脚本。可以使用Ruby脚本、Ruby的rake\thor等等，我为了简洁和性能，我了解了一下Shell，发现用Shell来做这个事情更合适。性能，命令行，管道，丰富的现有工具，基于Linux本身，Shell真是一个好东西。以前认为用Ruby来做这个事情是一个不错的选择，现在知道了，那是因为相比起Shell来，更熟悉Ruby，程序员总是喜欢自己熟悉的领域，而排斥自己不熟悉的领域。其实多了解一下其它方面的，更利用自己工作的开展，提高工作效率。</p>

<p>我随便总结一下几个知识点</p>

<h4>字符串</h4>

<p>声明一个字符串变量后，使用的时候，在变量名前面加一个$符号才能将其值取出来</p>

<p><code>
DATA_FILE=data.tar.gz
echo $DATA_FILE
</code></p>

<p>字符串拼接
<code>
DATA_DIR=/Users/caojinhua/code/
DATA_FILE=data.tar.gz
DATA_PATH=$DATA_DIR""$DATA_FILE
</code></p>

<p>将命令执行的结果保存在变量中
<code>
sha1=`ls -al`
</code></p>

<h4>if语句结构</h4>

<p>if语句条件测试命令：
<code>
[ -d DIR ]  如果DIR存在并且是一个目录则为真
[ -f FILE ] 如果FILE存在且是一个普通文件则为真
[ -z STRING ]   如果STRING的长度为零则为真
[ -n STRING ]   如果STRING的长度非零则为真
[ STRING1 = STRING2 ]   如果两个字符串相同则为真
[ STRING1 != STRING2 ]  如果字符串不相同则为真
[ ARG1 OP ARG2 ]
</code></p>

<p>ARG1和ARG2应该是整数或者取值为整数的变量，OP是-eq（等于）-ne（不等于）-lt（小于）-le（小于等于）-gt（大于）-ge（大于等于）之中的一个</p>

<p>之前弄错好几次，中括号前后的空格不能少。</p>

<p>if语句的结构</p>

<p>```
if [ xxx ]
then
fi</p>

<p>if [ xxx ]; then</p>

<p>else</p>

<p>fi</p>

<p>if [ xxx ]; then</p>

<p>elif [ ! xxx ]; then</p>

<p>fi
```</p>

<h4>时间格式化</h4>

<p>```
date  +%Y%m%d</p>

<p>a=<code>date +%Y%m%d</code>
echo $a
```</p>

<h4>参考资料</h4>

<p><a href="http://learn.akae.cn/media/ch31s05.html">Shell脚本语法</a></p>
]]></content>
  </entry>
  
</feed>
